$date
	Mon Nov 20 00:10:44 2023
$end
$version
	Icarus Verilog
$end
$timescale
	10ps
$end
$scope module microc_tb $end
$var wire 1 ! zero $end
$var wire 6 " Opcode [5:0] $end
$var reg 3 # ALUOp [2:0] $end
$var reg 1 $ clk $end
$var reg 1 % reset $end
$var reg 1 & s_inc $end
$var reg 1 ' s_inm $end
$var reg 1 ( we $end
$var reg 1 ) wez $end
$scope module microc_instanste $end
$var wire 3 * ALUOp [2:0] $end
$var wire 1 $ clk $end
$var wire 1 % reset $end
$var wire 1 & s_inc $end
$var wire 1 ' s_inm $end
$var wire 1 ( we $end
$var wire 1 ) wez $end
$var wire 1 ! zero $end
$var wire 1 + z_alu $end
$var wire 4 , out_mux_files [3:0] $end
$var wire 8 - out_alu_mux [7:0] $end
$var wire 10 . outSumPC [9:0] $end
$var wire 10 / new_pc [9:0] $end
$var wire 10 0 jump_dir [9:0] $end
$var wire 16 1 instruction [15:0] $end
$var wire 8 2 inmediate [7:0] $end
$var wire 10 3 actual_pc [9:0] $end
$var wire 8 4 WD3 [7:0] $end
$var wire 4 5 WA3 [3:0] $end
$var wire 8 6 RD2 [7:0] $end
$var wire 8 7 RD1 [7:0] $end
$var wire 4 8 RA2 [3:0] $end
$var wire 4 9 RA1 [3:0] $end
$var wire 6 : Opcode [5:0] $end
$scope module ProgramMemory $end
$var wire 16 ; Datum [15:0] $end
$var wire 1 $ clk $end
$var wire 10 < Address [9:0] $end
$upscope $end
$scope module flag $end
$var wire 1 ) carga $end
$var wire 1 $ clk $end
$var wire 1 % reset $end
$var wire 1 + d $end
$var reg 1 ! q $end
$upscope $end
$scope module muxPC $end
$var wire 10 = D1 [9:0] $end
$var wire 1 & s $end
$var wire 10 > Y [9:0] $end
$var wire 10 ? D0 [9:0] $end
$var parameter 32 @ WIDTH $end
$upscope $end
$scope module mux_alu $end
$var wire 8 A D1 [7:0] $end
$var wire 1 ' s $end
$var wire 8 B Y [7:0] $end
$var wire 8 C D0 [7:0] $end
$var parameter 32 D WIDTH $end
$upscope $end
$scope module mux_files $end
$var wire 4 E D0 [3:0] $end
$var wire 4 F D1 [3:0] $end
$var wire 1 ' s $end
$var wire 4 G Y [3:0] $end
$var parameter 32 H WIDTH $end
$upscope $end
$scope module pc $end
$var wire 10 I D [9:0] $end
$var wire 1 $ clk $end
$var wire 1 % reset $end
$var parameter 32 J WIDTH $end
$var reg 10 K Q [9:0] $end
$upscope $end
$scope module program_alu $end
$var wire 8 L B [7:0] $end
$var wire 3 M Op [2:0] $end
$var wire 8 N A [7:0] $end
$var reg 8 O S [7:0] $end
$var reg 1 + zero $end
$upscope $end
$scope module registerBank $end
$var wire 4 P RA1 [3:0] $end
$var wire 4 Q RA2 [3:0] $end
$var wire 4 R WA3 [3:0] $end
$var wire 8 S WD3 [7:0] $end
$var wire 1 $ clk $end
$var wire 1 ( we3 $end
$var wire 8 T RD2 [7:0] $end
$var wire 8 U RD1 [7:0] $end
$upscope $end
$scope module sumPC $end
$var wire 10 V A [9:0] $end
$var wire 10 W B [9:0] $end
$var wire 10 X Y [9:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b1010 J
b100 H
b1000 D
b1010 @
$end
#0
$dumpvars
b1 X
b1 W
b0 V
bx U
b0 T
bx S
b1 R
b1 Q
b0x P
bx O
bx N
bx M
b0x L
b0 K
b0x0001 I
b0x G
b1 F
b0 E
b0 C
b0x B
b1 A
b1 ?
b0x0001 >
b10001 =
b0 <
b10001 ;
b0 :
b0 9
b1 8
bx 7
b0 6
b1 5
bx 4
b0 3
b1 2
b10001 1
b10001 0
b0x0001 /
b1 .
b0x -
b0x ,
x+
bx *
x)
x(
x'
x&
1%
1$
bx #
b0 "
0!
$end
#500
0%
#2000
b0 7
b0 N
b0 U
0+
b1 4
b1 O
b1 S
b1 -
b1 B
b1 L
b1 ,
b1 G
b1 P
b10001 /
b10001 >
b10001 I
b0 #
b0 *
b0 M
1)
1(
1'
1&
0$
#4000
1+
b0 4
b0 O
b0 S
b0 -
b0 B
b0 L
b0 ,
b0 G
b0 P
b0 /
b0 >
b0 I
b0 2
b0 A
b0 5
b0 F
b0 Q
b0 8
b0 R
b100 "
b100 :
b0 0
b0 =
b0 7
b0 N
b0 U
b0 6
b0 C
b0 T
b10010 .
b10010 ?
b10010 X
b1000000000000 1
b1000000000000 ;
b10001 3
b10001 <
b10001 K
b10001 V
1$
#6000
0$
